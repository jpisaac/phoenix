package org.apache.phoenix.end2end;

import com.google.common.collect.Lists;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.hbase.HConstants;
import org.apache.hadoop.hbase.client.Result;
import org.apache.hadoop.hbase.client.ResultScanner;
import org.apache.hadoop.hbase.client.Scan;
import org.apache.hadoop.hbase.client.Table;
import org.apache.hadoop.hbase.filter.ColumnPrefixFilter;
import org.apache.hadoop.hbase.filter.CompareFilter;
import org.apache.hadoop.hbase.filter.FilterList;
import org.apache.hadoop.hbase.filter.RowFilter;
import org.apache.hadoop.hbase.filter.SubstringComparator;
import org.apache.hadoop.hbase.util.Bytes;
import org.apache.hadoop.io.DoubleWritable;
import org.apache.hadoop.io.NullWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.lib.db.DBWritable;
import org.apache.phoenix.iterate.TestingMapReduceParallelScanGrouper;
import org.apache.phoenix.jdbc.PhoenixDatabaseMetaData;
import org.apache.phoenix.mapreduce.PhoenixOutputFormat;
import org.apache.phoenix.mapreduce.PhoenixTestingInputFormat;
import org.apache.phoenix.mapreduce.util.PhoenixMapReduceUtil;
import org.apache.phoenix.query.PhoenixTestBuilder;
import org.apache.phoenix.query.QueryConstants;
import org.apache.phoenix.schema.PTable;
import org.apache.phoenix.util.IndexUtil;
import org.apache.phoenix.util.SchemaUtil;
import org.apache.phoenix.util.TestUtil;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import java.util.Random;

import static org.apache.phoenix.query.PhoenixTestBuilder.DDLDefaults.COLUMN_TYPES;
import static org.apache.phoenix.query.PhoenixTestBuilder.DDLDefaults.MAX_ROWS;
import static org.apache.phoenix.query.PhoenixTestBuilder.DDLDefaults.TENANT_VIEW_COLUMNS;
import static org.apache.phoenix.util.PhoenixRuntime.TENANT_ID_ATTRIB;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

public class ViewTTLMapReduceIT extends LocalHBaseIT {

    private static final Logger LOGGER = LoggerFactory.getLogger(ViewTTLIT.class);
    private static int DEFAULT_NUM_ROWS = 5;

    // Scans the HBase rows directly for the view ttl related header rows column and asserts
    private void assertViewHeaderRowsHaveViewTTLRelatedCells(String schemaName, long minTimestamp,
            int expectedRows) throws IOException, SQLException {

        FilterList filterList = new FilterList(FilterList.Operator.MUST_PASS_ALL);
        RowFilter schemaNameFilter = new RowFilter(
                CompareFilter.CompareOp.EQUAL,
                new SubstringComparator(schemaName)
        );
        ColumnPrefixFilter viewTTLPrefixFilter = new ColumnPrefixFilter(PhoenixDatabaseMetaData.PHOENIX_TTL_BYTES);
        filterList.addFilter(schemaNameFilter);
        filterList.addFilter(viewTTLPrefixFilter);
        try (Table tbl = driver.getConnectionQueryServices(getUrl(), TestUtil.TEST_PROPERTIES)
                .getTable(PhoenixDatabaseMetaData.SYSTEM_CATALOG_NAME_BYTES)) {

            Scan allRows = new Scan();
            allRows.setRaw(true);
            allRows.setTimeRange(minTimestamp, HConstants.LATEST_TIMESTAMP);
            allRows.setFilter(filterList);
            ResultScanner scanner = tbl.getScanner(allRows);
            int numMatchingRows = 0;
            for (Result result = scanner.next(); result != null; result = scanner.next()) {
                numMatchingRows +=
                        result.containsColumn(QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,
                                PhoenixDatabaseMetaData.PHOENIX_TTL_BYTES) ? 1 : 0;
            }
            assertEquals(String.format("Expected rows do match for table = %s at timestamp %d",
                    Bytes.toString(PhoenixDatabaseMetaData.SYSTEM_CATALOG_NAME_BYTES), minTimestamp), expectedRows, numMatchingRows);
        }

    }
    // Scans the HBase rows directly for the empty column and asserts
    private void assertTTLExpiredRowsAreMasked(String sql, long oldestUnexpiredTimestamp,
            int expectedRows)
            throws IOException, SQLException, ClassNotFoundException, InterruptedException {
        runJob(null, sql, expectedRows);
    }

    private void runJob(String tenantId, String query, int expectedRows)
            throws SQLException, InterruptedException, IOException, ClassNotFoundException {

        assertEquals("Failed to reset getRegionBoundaries counter for scanGrouper", 0,
                TestingMapReduceParallelScanGrouper.getNumCallsToGetRegionBoundaries());
        //upsertData(conn, stockTableName);

        final Configuration conf = getUtility().getConfiguration();
        Job job = Job.getInstance(conf);

        PhoenixMapReduceUtil.setTenantId(job, tenantId);
        //PhoenixMapReduceUtil.setViewTTL(job, 10);
        PhoenixMapReduceUtil
                .setInput(job, MapReduceIT.StockWritable.class, PhoenixTestingInputFormat.class,
                        null, query);


        // only run locally, rather than having to spin up a MiniMapReduce cluster and lets us use breakpoints
        job.getConfiguration().set("mapreduce.framework.name", "local");
        job.getConfiguration().set(HConstants.ZOOKEEPER_QUORUM, "jisaac-ltm");
        job.getConfiguration().set(HConstants.ZOOKEEPER_CLIENT_PORT, "2181");
        job.getConfiguration().set(HConstants.ZOOKEEPER_ZNODE_PARENT, HConstants.DEFAULT_ZOOKEEPER_ZNODE_PARENT);
        //setOutput(job, stockStatsTableName);

        job.setMapperClass(MapReduceIT.StockMapper.class);
        job.setReducerClass(MapReduceIT.StockReducer.class);
        job.setOutputFormatClass(PhoenixOutputFormat.class);

        job.setMapOutputKeyClass(Text.class);
        job.setMapOutputValueClass(DoubleWritable.class);
        job.setOutputKeyClass(NullWritable.class);
        job.setOutputValueClass(MapReduceIT.StockWritable.class);

        // run job
        assertTrue("Job didn't complete successfully! Check logs for reason.", job.waitForCompletion(true));

        // verify
        assertEquals("There should have been only be 1 call to getRegionBoundaries "
                        + "(corresponding to the driver code)", 1,
                TestingMapReduceParallelScanGrouper.getNumCallsToGetRegionBoundaries());
    }

    /**
     * -----------------
     * Test methods
     * -----------------
     */

    @Test
    public void testWithBasicTenantViewWithNoViewTTLDefined() throws Exception {

        long startTime = System.currentTimeMillis();
        // Define the test schema.
        PhoenixTestBuilder.SchemaBuilder.TableOptions
                tableOptions = PhoenixTestBuilder.SchemaBuilder.TableOptions.withDefaults();
        tableOptions.getTablePKColumns().add("ID");
        tableOptions.getTablePKColumnTypes().add("CHAR(15)");
        tableOptions.getTableColumns().clear();
        tableOptions.getTableColumnTypes().clear();

        final PhoenixTestBuilder.SchemaBuilder schemaBuilder = new PhoenixTestBuilder.SchemaBuilder(getUrl());
        schemaBuilder.withTableOptions(tableOptions).build();

        // Define the test data.
        PhoenixTestBuilder.DataSupplier dataSupplier = new PhoenixTestBuilder.DataSupplier() {

            final String
                    orgId =
                    String.format("00D0x000%s", schemaBuilder.getDataOptions().getUniqueName());
            final String kp = SchemaUtil.normalizeIdentifier(schemaBuilder.getEntityKeyPrefix());

            @Override public List<Object> getValues(int rowIndex) {
                String id = String.format("00A0y000%07d", rowIndex);
                return Lists.newArrayList(new Object[] { orgId, kp, id });
            }
        };

        // Create a test data writer for the above schema.
        PhoenixTestBuilder.DataWriter dataWriter = new PhoenixTestBuilder.BasicDataWriter();
        try (Connection connection = DriverManager.getConnection(getUrl())) {
            connection.setAutoCommit(true);
            dataWriter.setConnection(connection);
            dataWriter.setDataSupplier(dataSupplier);
            dataWriter.setUpsertColumns(Lists.newArrayList("OID", "KP", "ID"));
            dataWriter.setTargetEntity(schemaBuilder.getEntityTableName());

        }
        assertViewHeaderRowsHaveViewTTLRelatedCells(schemaBuilder.getTableOptions().getSchemaName(), startTime, 1);
    }



    @Test
    public void testWhenCustomTenantViewWithIndexAndOneOptions() throws Exception {

        boolean isGlobalViewLocal = false;
        boolean isTenantViewLocal = false;

        List<PhoenixTestBuilder.SchemaBuilder.OtherOptions> testCases = Lists.newArrayList();
        PhoenixTestBuilder.SchemaBuilder.OtherOptions
                testCaseWhenAllCFMatchAndAllDefault = new PhoenixTestBuilder.SchemaBuilder.OtherOptions();
        testCaseWhenAllCFMatchAndAllDefault.setTestName("testCaseWhenAllCFMatchAndAllDefault");
        testCaseWhenAllCFMatchAndAllDefault
                .setTableCFs(Lists.newArrayList((String) null, null, null));
        testCaseWhenAllCFMatchAndAllDefault
                .setGlobalViewCFs(Lists.newArrayList((String) null, null, null));
        testCaseWhenAllCFMatchAndAllDefault
                .setTenantViewCFs(Lists.newArrayList((String) null, null, null));
        testCases.add(testCaseWhenAllCFMatchAndAllDefault);


        for (String additionalProps : Lists
                .newArrayList("COLUMN_ENCODED_BYTES=0")) {

            StringBuilder withTableProps = new StringBuilder();
            withTableProps.append("MULTI_TENANT=true,").append(additionalProps);


            for (PhoenixTestBuilder.SchemaBuilder.OtherOptions options : testCases) {

                // Define the test schema
                PhoenixTestBuilder.SchemaBuilder.TableOptions
                        tableOptions = PhoenixTestBuilder.SchemaBuilder.TableOptions.withDefaults();
                tableOptions.setTableProps(withTableProps.toString());

                PhoenixTestBuilder.SchemaBuilder.GlobalViewIndexOptions
                        globalViewIndexOptions =
                        PhoenixTestBuilder.SchemaBuilder.GlobalViewIndexOptions.withDefaults();
                globalViewIndexOptions.setLocal(isGlobalViewLocal);

                PhoenixTestBuilder.SchemaBuilder.TenantViewOptions
                        tenantViewOptions = new PhoenixTestBuilder.SchemaBuilder.TenantViewOptions();
                tenantViewOptions
                        .setTenantViewColumns(Lists.newArrayList(TENANT_VIEW_COLUMNS));
                tenantViewOptions
                        .setTenantViewColumnTypes(Lists.newArrayList(COLUMN_TYPES));

                PhoenixTestBuilder.SchemaBuilder.TenantViewIndexOptions
                        tenantViewIndexOptions =
                        PhoenixTestBuilder.SchemaBuilder.TenantViewIndexOptions.withDefaults();
                tenantViewIndexOptions.setLocal(isTenantViewLocal);

                final PhoenixTestBuilder.SchemaBuilder
                        schemaBuilder = new PhoenixTestBuilder.SchemaBuilder(getUrl());
                schemaBuilder.withTableOptions(tableOptions).withGlobalViewDefaults()
                        .withGlobalViewIndexOptions(globalViewIndexOptions)
                        .withTenantViewOptions(tenantViewOptions)
                        .withTenantViewIndexOptions(tenantViewIndexOptions)
                        .withOtherOptions(options).buildWithNewTenant();

                // Define the test data.
                PhoenixTestBuilder.DataSupplier dataSupplier = new PhoenixTestBuilder.DataSupplier() {

                    @Override public List<Object> getValues(int rowIndex) {
                        Random rnd = new Random();
                        String id = String.format("00A0y000%07d", rowIndex);
                        String
                                col1 =
                                String.format("a%05d", rowIndex + rnd.nextInt(MAX_ROWS));
                        String
                                col2 =
                                String.format("b%05d", rowIndex + rnd.nextInt(MAX_ROWS));
                        String
                                col3 =
                                String.format("c%05d", rowIndex + rnd.nextInt(MAX_ROWS));
                        String
                                col4 =
                                String.format("d%05d", rowIndex + rnd.nextInt(MAX_ROWS));
                        String
                                col5 =
                                String.format("e%05d", rowIndex + rnd.nextInt(MAX_ROWS));
                        String
                                col6 =
                                String.format("f%05d", rowIndex + rnd.nextInt(MAX_ROWS));
                        String
                                col7 =
                                String.format("g%05d", rowIndex + rnd.nextInt(MAX_ROWS));
                        String
                                col8 =
                                String.format("h%05d", rowIndex + rnd.nextInt(MAX_ROWS));
                        String
                                col9 =
                                String.format("i%05d", rowIndex + rnd.nextInt(MAX_ROWS));

                        return Lists.newArrayList(
                                new Object[] { id, col1, col2, col3, col4, col5, col6, col7,
                                        col8, col9 });
                    }
                };

                // Create a test data writer for the above schema.
                PhoenixTestBuilder.DataWriter dataWriter = new PhoenixTestBuilder.BasicDataWriter();
                String
                        tenantConnectUrl =
                        getUrl() + ';' + TENANT_ID_ATTRIB + '=' + schemaBuilder
                                .getDataOptions().getTenantId();
                try (Connection connection = DriverManager
                        .getConnection(tenantConnectUrl)) {
                    connection.setAutoCommit(true);
                    dataWriter.setConnection(connection);
                    dataWriter.setDataSupplier(dataSupplier);
                    dataWriter.setUpsertColumns(
                            Lists.newArrayList("ID", "COL1", "COL2", "COL3", "COL4", "COL5",
                                    "COL6", "COL7", "COL8", "COL9"));
                    dataWriter.setTargetEntity(schemaBuilder.getEntityTenantViewName());

                    // upsertValues column positions to be used for partial updates.
                    List<Integer> columnsForPartialUpdates = Lists.newArrayList(0, 7, 9);
                    // No index for table.
                    // COL6 is the include column for the global view index => index pos of 2
                    // COL7 is the include column for the tenant view index => index pos of 0
                    List<Integer>
                            includeColumnPositionOfIndexes =
                            Lists.newArrayList(null, 2, 0);
                    // Write the data and run validations
                    try {
                        LOGGER.debug(String.format("### BEGIN %s",
                                schemaBuilder.getOtherOptions().getTestName()));
                        /**
                         * WHEN global and tenant view indexes are
                         * either both local or both global i.e index rows are co-located.
                         * AND
                         * WHEN the CFs of the include columns match.
                         * THEN the # of index rows in the table (when local) and
                         * 		in the index table (when global)
                         * # of index rows => # of upserted rows * # of indexes
                         * ELSE
                         * # of index rows => # of upserted rows
                         */
                        ExpectedTestResults
                                expectedTestResults =
                                new ExpectedTestResults(DEFAULT_NUM_ROWS, 0,
                                        DEFAULT_NUM_ROWS);
                        boolean colocated = !(isGlobalViewLocal ^ isTenantViewLocal);
                        boolean
                                cfsAreNull =
                                (options.getGlobalViewCFs().get(2) == null
                                        && options.getGlobalViewCFs().get(2) == options
                                        .getTenantViewCFs().get(0));
                        boolean
                                cfsAreNotNullButEqual =
                                !(cfsAreNull) && (options.getGlobalViewCFs().get(2)
                                        .equalsIgnoreCase(
                                                options.getTenantViewCFs().get(0)));
                        if (colocated && (cfsAreNull || cfsAreNotNullButEqual)) {
                            expectedTestResults =
                                    new ExpectedTestResults(DEFAULT_NUM_ROWS, 0,
                                            DEFAULT_NUM_ROWS * 2);
                        }
                        upsertDataAndRunValidations(DEFAULT_NUM_ROWS, expectedTestResults,
                                dataWriter, schemaBuilder, columnsForPartialUpdates,
                                includeColumnPositionOfIndexes);
                        LOGGER.debug(String.format(
                                "### Case => [GlobalView (local) = %b, "
                                        + "TenantView (local) = %b] : %s",
                                isGlobalViewLocal, isTenantViewLocal, "Passed"));
                    } catch (AssertionError ae) {
                        LOGGER.debug(String.format(
                                "### Case => [GlobalView (local) = %b, "
                                        + "TenantView (local) = %b] : %s",
                                isGlobalViewLocal, isTenantViewLocal, ae.getMessage()));
                    } finally {
                        LOGGER.debug(String.format("### END %s",
                                schemaBuilder.getOtherOptions().getTestName()));
                    }
                }
            }
        }
    }


    private void upsertDataAndRunValidations(int numRowsToUpsert,
            ExpectedTestResults expectedTestResults, PhoenixTestBuilder.DataWriter dataWriter,
            PhoenixTestBuilder.SchemaBuilder schemaBuilder, List<Integer> overriddenColumnsPositions)
            throws IOException, SQLException, ClassNotFoundException, InterruptedException {

        //Insert for the first time and validate them.
        validateTTLExpiredRowsAreMasked(upsertData(dataWriter, numRowsToUpsert), expectedTestResults,
                schemaBuilder, Lists.newArrayList(new Integer[] {}));
        // Update the above rows and validate the same.
        validateTTLExpiredRowsAreMasked(upsertData(dataWriter, numRowsToUpsert), expectedTestResults,
                schemaBuilder, Lists.newArrayList(new Integer[] {}));

        if (overriddenColumnsPositions != null && overriddenColumnsPositions.size() > 0) {
            dataWriter.setColumnPositionsToUpdate(overriddenColumnsPositions);
        }
        // Upsert and validate the partially updated rows.
        validateTTLExpiredRowsAreMasked(upsertData(dataWriter, numRowsToUpsert), expectedTestResults,
                schemaBuilder, Lists.newArrayList(new Integer[] {}));
    }

    private void upsertDataAndRunValidations(int numRowsToUpsert,
            ExpectedTestResults expectedTestResults, PhoenixTestBuilder.DataWriter dataWriter,
            PhoenixTestBuilder.SchemaBuilder schemaBuilder, List<Integer> overriddenColumnsPositions,
            List<Integer> indexedCFPositions)
            throws IOException, SQLException, ClassNotFoundException, InterruptedException {

        //Insert for the first time and validate them.
        validateTTLExpiredRowsAreMasked(upsertData(dataWriter, numRowsToUpsert), expectedTestResults,
                schemaBuilder, indexedCFPositions);
        // Update the above rows and validate the same.
        validateTTLExpiredRowsAreMasked(upsertData(dataWriter, numRowsToUpsert), expectedTestResults,
                schemaBuilder, indexedCFPositions);

        if (overriddenColumnsPositions != null && overriddenColumnsPositions.size() > 0) {
            dataWriter.setColumnPositionsToUpdate(overriddenColumnsPositions);
        }
        // Upsert and validate the partially updated rows.
        validateTTLExpiredRowsAreMasked(upsertData(dataWriter, numRowsToUpsert), expectedTestResults,
                schemaBuilder, indexedCFPositions);
    }

    private long upsertData(PhoenixTestBuilder.DataWriter dataWriter, int numRowsToUpsert) throws SQLException {
        // Upsert rows
        long earliestTimestamp = System.currentTimeMillis();
        for (int i = 0; i < numRowsToUpsert; i++) {
            dataWriter.upsertRow(i);
        }
        return earliestTimestamp;
    }

    private void validateTTLExpiredRowsAreMasked(long earliestTimestamp,
            ExpectedTestResults expectedTestResults, PhoenixTestBuilder.SchemaBuilder schemaBuilder,
            List<Integer> indexedCFPositions)
            throws IOException, SQLException, InterruptedException, ClassNotFoundException {

        // Base table's empty CF and column name
        PTable table = schemaBuilder.getBaseTable();
        byte[] emptyColumnFamilyName = SchemaUtil.getEmptyColumnFamily(table);
        byte[]
                emptyColumnName =
                table.getEncodingScheme() == PTable.QualifierEncodingScheme.NON_ENCODED_QUALIFIERS ?
                        QueryConstants.EMPTY_COLUMN_BYTES :
                        table.getEncodingScheme().encode(QueryConstants.ENCODED_EMPTY_COLUMN_NAME);

        byte[]
                hbaseBaseTableName =
                SchemaUtil.getTableNameAsBytes(table.getSchemaName().getString(),
                        table.getTableName().getString());
        byte[] hbaseIndexTableName = Bytes.toBytes("");
        byte[] indexColumnFamilyName = Bytes.toBytes("");

        byte[] hbaseGlobalViewIndexTableName = Bytes.toBytes("");
        byte[] globalViewIndexCFName = Bytes.toBytes("");

        byte[] hbaseTenantViewIndexTableName = Bytes.toBytes("");
        byte[] tenantViewIndexCFName = Bytes.toBytes("");

        boolean assertOnIndexTable = false;
        boolean assertOnGlobalIndexTable = false;
        boolean assertOnTenantIndexTable = false;

        // Find the index CF name when table index exists.
        if (schemaBuilder.isTableIndexEnabled() && schemaBuilder.isTableIndexCreated()
                && indexedCFPositions.size() > 0) {
            String tableIndexName = String.format("IDX_%s", table.getTableName().getString());
            // The table holding the index data - depends on whether index is local or global.
            hbaseIndexTableName =
                    schemaBuilder.getTableIndexOptions().isLocal() ?
                            hbaseBaseTableName :
                            SchemaUtil.getTableNameAsBytes(table.getSchemaName().getString(),
                                    tableIndexName);
            String
                    testDataColumnFamilyName =
                    schemaBuilder.getOtherOptions().getTableCFs().get(indexedCFPositions.get(0));
            String
                    dataColumnFamilyName =
                    testDataColumnFamilyName == null ?
                            Bytes.toString(emptyColumnFamilyName) :
                            testDataColumnFamilyName;
            indexColumnFamilyName =
                    Bytes.toBytes(schemaBuilder.getTableIndexOptions().isLocal() ?
                            IndexUtil.getLocalIndexColumnFamily(dataColumnFamilyName) :
                            dataColumnFamilyName);
            LOGGER.debug(String.format("### Table Index CF name : %s, Table Index table name : %s",
                    Bytes.toString(indexColumnFamilyName), Bytes.toString(hbaseIndexTableName)));
            assertOnIndexTable = true;
        }

        // Find the index CF name when global view index exists.
        if (schemaBuilder.isGlobalViewIndexEnabled() && schemaBuilder.isGlobalViewIndexCreated()
                && indexedCFPositions.size() > 0) {
            String
                    viewIndexSchemaName =
                    String.format("_IDX_%s", table.getSchemaName().getString());
            hbaseGlobalViewIndexTableName =
                    schemaBuilder.getGlobalViewIndexOptions().isLocal() ?
                            hbaseBaseTableName :
                            SchemaUtil.getTableNameAsBytes(viewIndexSchemaName,
                                    table.getTableName().getString());

            String
                    testDataColumnFamilyName =
                    schemaBuilder.getOtherOptions().getGlobalViewCFs()
                            .get(indexedCFPositions.get(1));
            String
                    dataColumnFamilyName =
                    testDataColumnFamilyName == null ?
                            Bytes.toString(emptyColumnFamilyName) :
                            testDataColumnFamilyName;
            globalViewIndexCFName =
                    Bytes.toBytes(schemaBuilder.getGlobalViewIndexOptions().isLocal() ?
                            IndexUtil.getLocalIndexColumnFamily(dataColumnFamilyName) :
                            dataColumnFamilyName);
            LOGGER.info(String.format(
                    "### Global View Index CF name : %s, Global View Index table name : %s",
                    Bytes.toString(indexColumnFamilyName),
                    Bytes.toString(hbaseGlobalViewIndexTableName)));
            assertOnGlobalIndexTable = true;
        }

        // Find the index CF name when tenant view index exists.
        if (schemaBuilder.isTenantViewIndexEnabled() && schemaBuilder.isTenantViewIndexCreated()
                && indexedCFPositions.size() > 0) {
            String
                    viewIndexSchemaName =
                    String.format("_IDX_%s", table.getSchemaName().getString());
            hbaseTenantViewIndexTableName =
                    schemaBuilder.getTenantViewIndexOptions().isLocal() ?
                            hbaseBaseTableName :
                            SchemaUtil.getTableNameAsBytes(viewIndexSchemaName,
                                    table.getTableName().getString());

            String
                    testDataColumnFamilyName =
                    schemaBuilder.getOtherOptions().getTenantViewCFs()
                            .get(indexedCFPositions.get(2));
            String
                    dataColumnFamilyName =
                    testDataColumnFamilyName == null ?
                            Bytes.toString(emptyColumnFamilyName) :
                            testDataColumnFamilyName;
            tenantViewIndexCFName =
                    Bytes.toBytes(schemaBuilder.getTenantViewIndexOptions().isLocal() ?
                            IndexUtil.getLocalIndexColumnFamily(dataColumnFamilyName) :
                            dataColumnFamilyName);
            LOGGER.info(String.format("### Tenant Index CF name : %s, Tenant Index table name : %s",
                    Bytes.toString(indexColumnFamilyName),
                    Bytes.toString(hbaseTenantViewIndexTableName)));
            assertOnTenantIndexTable = true;
        }

        // Assert on base table rows
        assertTTLExpiredRowsAreMasked(String.format("SELECT * from %s",
                Bytes.toString(hbaseBaseTableName)),
                earliestTimestamp, expectedTestResults.numTableRowsExpected);

        // Assert on index table rows
        if (assertOnIndexTable) {
            assertTTLExpiredRowsAreMasked(String.format("SELECT * from %s",
                    Bytes.toString(hbaseIndexTableName)), earliestTimestamp,
                    expectedTestResults.numTableIndexRowsExpected);
        }
        // Assert on global view index table rows
        if (assertOnGlobalIndexTable) {
            assertTTLExpiredRowsAreMasked(String.format("SELECT * from %s",
                    Bytes.toString(hbaseGlobalViewIndexTableName)), earliestTimestamp,
                    expectedTestResults.numViewIndexRowsExpected);
        }
        // Assert on tenant view index table rows
        if (assertOnTenantIndexTable) {
            assertTTLExpiredRowsAreMasked(String.format("SELECT * from %s",
                    Bytes.toString(hbaseTenantViewIndexTableName)), earliestTimestamp,
                    expectedTestResults.numViewIndexRowsExpected);
        }

    }

    private void validateEmptyColumnsAreUpdated(long earliestTimestamp,
            ExpectedTestResults expectedTestResults, PhoenixTestBuilder.SchemaBuilder schemaBuilder,
            List<Integer> indexedCFPositions) throws IOException, SQLException {

        // Base table's empty CF and column name
        PTable table = schemaBuilder.getBaseTable();
        byte[] emptyColumnFamilyName = SchemaUtil.getEmptyColumnFamily(table);
        byte[]
                emptyColumnName =
                table.getEncodingScheme() == PTable.QualifierEncodingScheme.NON_ENCODED_QUALIFIERS ?
                        QueryConstants.EMPTY_COLUMN_BYTES :
                        table.getEncodingScheme().encode(QueryConstants.ENCODED_EMPTY_COLUMN_NAME);

        byte[]
                hbaseBaseTableName =
                SchemaUtil.getTableNameAsBytes(table.getSchemaName().getString(),
                        table.getTableName().getString());
        byte[] hbaseIndexTableName = Bytes.toBytes("");
        byte[] indexColumnFamilyName = Bytes.toBytes("");

        byte[] hbaseGlobalViewIndexTableName = Bytes.toBytes("");
        byte[] globalViewIndexCFName = Bytes.toBytes("");

        byte[] hbaseTenantViewIndexTableName = Bytes.toBytes("");
        byte[] tenantViewIndexCFName = Bytes.toBytes("");

        boolean assertOnIndexTable = false;
        boolean assertOnGlobalIndexTable = false;
        boolean assertOnTenantIndexTable = false;

        // Find the index CF name when table index exists.
        if (schemaBuilder.isTableIndexEnabled() && schemaBuilder.isTableIndexCreated()
                && indexedCFPositions.size() > 0) {
            String tableIndexName = String.format("IDX_%s", table.getTableName().getString());
            // The table holding the index data - depends on whether index is local or global.
            hbaseIndexTableName =
                    schemaBuilder.getTableIndexOptions().isLocal() ?
                            hbaseBaseTableName :
                            SchemaUtil.getTableNameAsBytes(table.getSchemaName().getString(),
                                    tableIndexName);
            String
                    testDataColumnFamilyName =
                    schemaBuilder.getOtherOptions().getTableCFs().get(indexedCFPositions.get(0));
            String
                    dataColumnFamilyName =
                    testDataColumnFamilyName == null ?
                            Bytes.toString(emptyColumnFamilyName) :
                            testDataColumnFamilyName;
            indexColumnFamilyName =
                    Bytes.toBytes(schemaBuilder.getTableIndexOptions().isLocal() ?
                            IndexUtil.getLocalIndexColumnFamily(dataColumnFamilyName) :
                            dataColumnFamilyName);
            LOGGER.debug(String.format("### Table Index CF name : %s, Table Index table name : %s",
                    Bytes.toString(indexColumnFamilyName), Bytes.toString(hbaseIndexTableName)));
            assertOnIndexTable = true;
        }

        // Find the index CF name when global view index exists.
        if (schemaBuilder.isGlobalViewIndexEnabled() && schemaBuilder.isGlobalViewIndexCreated()
                && indexedCFPositions.size() > 0) {
            String
                    viewIndexSchemaName =
                    String.format("_IDX_%s", table.getSchemaName().getString());
            hbaseGlobalViewIndexTableName =
                    schemaBuilder.getGlobalViewIndexOptions().isLocal() ?
                            hbaseBaseTableName :
                            SchemaUtil.getTableNameAsBytes(viewIndexSchemaName,
                                    table.getTableName().getString());

            String
                    testDataColumnFamilyName =
                    schemaBuilder.getOtherOptions().getGlobalViewCFs()
                            .get(indexedCFPositions.get(1));
            String
                    dataColumnFamilyName =
                    testDataColumnFamilyName == null ?
                            Bytes.toString(emptyColumnFamilyName) :
                            testDataColumnFamilyName;
            globalViewIndexCFName =
                    Bytes.toBytes(schemaBuilder.getGlobalViewIndexOptions().isLocal() ?
                            IndexUtil.getLocalIndexColumnFamily(dataColumnFamilyName) :
                            dataColumnFamilyName);
            LOGGER.info(String.format(
                    "### Global View Index CF name : %s, Global View Index table name : %s",
                    Bytes.toString(indexColumnFamilyName),
                    Bytes.toString(hbaseGlobalViewIndexTableName)));
            assertOnGlobalIndexTable = true;
        }

        // Find the index CF name when tenant view index exists.
        if (schemaBuilder.isTenantViewIndexEnabled() && schemaBuilder.isTenantViewIndexCreated()
                && indexedCFPositions.size() > 0) {
            String
                    viewIndexSchemaName =
                    String.format("_IDX_%s", table.getSchemaName().getString());
            hbaseTenantViewIndexTableName =
                    schemaBuilder.getTenantViewIndexOptions().isLocal() ?
                            hbaseBaseTableName :
                            SchemaUtil.getTableNameAsBytes(viewIndexSchemaName,
                                    table.getTableName().getString());

            String
                    testDataColumnFamilyName =
                    schemaBuilder.getOtherOptions().getTenantViewCFs()
                            .get(indexedCFPositions.get(2));
            String
                    dataColumnFamilyName =
                    testDataColumnFamilyName == null ?
                            Bytes.toString(emptyColumnFamilyName) :
                            testDataColumnFamilyName;
            tenantViewIndexCFName =
                    Bytes.toBytes(schemaBuilder.getTenantViewIndexOptions().isLocal() ?
                            IndexUtil.getLocalIndexColumnFamily(dataColumnFamilyName) :
                            dataColumnFamilyName);
            LOGGER.info(String.format("### Tenant Index CF name : %s, Tenant Index table name : %s",
                    Bytes.toString(indexColumnFamilyName),
                    Bytes.toString(hbaseTenantViewIndexTableName)));
            assertOnTenantIndexTable = true;
        }

        /*
        // Assert on base table rows
        assertAllHBaseRowsHaveEmptyColumnCell(hbaseBaseTableName, emptyColumnFamilyName,
                emptyColumnName, earliestTimestamp, expectedTestResults.numTableRowsExpected);
        // Assert on index table rows
        if (assertOnIndexTable) {
            assertAllHBaseRowsHaveEmptyColumnCell(hbaseIndexTableName, indexColumnFamilyName,
                    emptyColumnName, earliestTimestamp,
                    expectedTestResults.numTableIndexRowsExpected);
        }
        // Assert on global view index table rows
        if (assertOnGlobalIndexTable) {
            assertAllHBaseRowsHaveEmptyColumnCell(hbaseGlobalViewIndexTableName,
                    globalViewIndexCFName, emptyColumnName, earliestTimestamp,
                    expectedTestResults.numViewIndexRowsExpected);
        }
        // Assert on tenant view index table rows
        if (assertOnTenantIndexTable) {
            assertAllHBaseRowsHaveEmptyColumnCell(hbaseTenantViewIndexTableName,
                    tenantViewIndexCFName, emptyColumnName, earliestTimestamp,
                    expectedTestResults.numViewIndexRowsExpected);
        }

        */
    }

    private static class ExpectedTestResults {
        int numTableRowsExpected;
        int numTableIndexRowsExpected;
        int numViewIndexRowsExpected;

        public ExpectedTestResults(int numTableRowsExpected, int numTableIndexRowsExpected,
                int numViewIndexRowsExpected) {
            this.numTableRowsExpected = numTableRowsExpected;
            this.numTableIndexRowsExpected = numTableIndexRowsExpected;
            this.numViewIndexRowsExpected = numViewIndexRowsExpected;
        }
    }

    // A Data Reader to be used in tests to read sample data from phoenix db.
    public interface DataReader {
        List<String> getSelectColumns();

        void setSelectColumns(List<String> selectColumns);

        String getWhereClause();

        void setWhereClause(String whereClause);

        // returns the connection to be used for upserting rows.
        Connection getConnection();

        void setConnection(Connection connection);

        // returns the target entity - whether to use the table, global-view, the tenant-view or
        // an index table.
        String getTargetEntity();

        void setTargetEntity(String targetEntity);

    }

    public static class ViewTTLTestDataWritable implements DBWritable {

        private String stockName;
        private double[] recordings;
        private double maxPrice;

        @Override
        public void readFields(ResultSet rs) throws SQLException {
        }

        @Override
        public void write(PreparedStatement pstmt) throws SQLException {
        }

        public double[] getRecordings() {
            return recordings;
        }

        public String getStockName() {
            return stockName;
        }

        public void setStockName(String stockName) {
            this.stockName = stockName;
        }

        public void setMaxPrice(double maxPrice) {
            this.maxPrice = maxPrice;
        }
    }

}
